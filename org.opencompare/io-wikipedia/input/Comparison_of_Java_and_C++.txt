{{Multiple issues|
{{unreliable sources|date=September 2010}}
{{unbalanced|date=October 2010}}
{{self-published|date=September 2010}}
{{original research|date=August 2012}}
{{cleanup|date=February 2011}}
}}

{{ProgLangCompare}}
This is a '''comparison of the [[Java (programming language)|Java programming language]] with the [[C++|C++ programming language]]'''.

== Design aims ==
The differences between the C++ and Java programming languages can be traced to their [[Virtual Heritage|heritage]], as they have different design goals.{{Citation needed|date=February 2015}}
* '''C++''' was designed for systems and applications programming (a.k.a. infrastructure programming), extending the [[C (programming language)|C programming language]]. To this [[procedural programming]] language designed for efficient execution, C++ has added support for [[static typing|statically typed]] [[object-oriented programming]], [[exception handling]], lifetime-based resource management ([[RAII]]), [[generic programming]], and [[template metaprogramming]], in particular. It also added a [[C++ Standard Library|standard library]] which includes generic containers and algorithms (STL), as well as many other general purpose facilities.
* '''Java''' is a general-purpose, concurrent, class-based, object-oriented computer programming language that is specifically designed to have as few implementation dependencies as possible. It relies on a [[Java virtual machine]] to be [[computer security|secure]] and highly [[porting|portable]]. It is bundled with an extensive library designed to provide a complete abstraction of the underlying platform. Java is a statically typed object-oriented language that uses similar (but incompatible) syntax to C++. It includes a documentation system called [[Javadoc]].
The different goals in the development of C++ and Java resulted in different principles and design tradeoffs between the languages.
The differences are as follows :

{| class="wikitable"
! style="width:50%;"| C++
! style="width:50%;"| Java
|-
| Extension of C with [[object-oriented programming]], still able to run C code.
| Strongly influenced by C++/C syntax.
|-
| Compatible with [[C (programming language)|C]] source code, except for a few [[corner case]]s.
| Provides the [[Java Native Interface]] and recently [[Java Native Access]] as a way to directly call C/C++ code. 
|-
| [[Write once, compile anywhere|Write once, compile anywhere (WOCA)]].
| [[Write once, run anywhere|Write once, run anywhere / everywhere (WORA / WORE)]].
|-
| Allows [[procedural programming]], [[functional programming]], [[object-oriented programming]], [[generic programming]], and [[template metaprogramming]]. Favors a mix of paradigms.
| Allows [[procedural programming]], [[functional programming]] (since Java 8) and [[generic programming]] (since Java 5), but strongly encourages the [[object-oriented programming|object-oriented]] [[programming paradigm]]. Includes support for the creation of [[scripting languages]].
|-
| Runs as native executable machine code for the target [[instruction set]](s).
| Runs in a [[Java virtual machine|virtual machine]].
|-
| Provides object types and type names. Allows reflection through [[Run-time type information|RTTI]].
| Is [[Reflection (computer programming)|reflective]], allowing metaprogramming and dynamic code generation at runtime.
|-
| Has multiple binary compatibility standards (commonly Microsoft (for MSVC compiler) and Itanium/GNU (for virtually all other compilers)).
| Has a single, OS- and compiler-independent binary compatibility standard.
|-
| Optional automated [[bounds checking]] (e.g., the <tt>at()</tt> method in <tt>vector</tt> and <tt>string</tt> containers).
| All operations are required to be Bound-checked by all compliant distributions of Java. [[HotSpot]] can remove bounds checking.
|-
| Supports native [[Unsigned (arithmetic)|unsigned arithmetic]].
| No native support for [[Unsigned (arithmetic)|unsigned arithmetic]]. <!-- Java 8 changes some stuff here, but it's unclear exactly what <ref>https://blogs.oracle.com/darcy/entry/unsigned_api</ref> -->
|-
| Standardized minimum limits for all numerical types, but the actual sizes are implementation-defined. Standardized types are available through the standard library <code><cstdint></code>.
| Standardized limits and sizes of all primitive types on all platforms.
|-
| Pointers, references, and pass-by-value are supported for all types (primitive or user-defined).
| All types (primitive types and reference types) are always passed by value.<ref>{{cite web | url = http://download.oracle.com/javase/tutorial/java/javaOO/arguments.html | title = The Java Tutorials: Passing Information to a Method or a Constructor | publisher = Oracle | accessdate=17 February 2013 }}</ref>
|-
| [[Memory management]] can be done [[manual memory management|manually]] through <code>new / delete</code>, automatically by scope, or by smart pointers. Supports deterministic destruction of objects. Garbage collection ABI standardized in C++11, though compilers are not required to implement [[Garbage collection (computer science)|garbage collection]].
| Automatic [[Garbage collection (computer science)|garbage collection]]. Supports a non-deterministic finalize() method whose use is not recommended.<ref>{{cite web | url = http://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html | title = The Java Tutorials: Object as a Superclass | publisher = Oracle | accessdate=17 February 2013 }}.</ref>
|-
| [[Resource management]] can be done manually or by automatic lifetime-based resource management ([[RAII]]).
| Resource management must be done manually, or automatically via finalizers, though this is generally discouraged. Has try-with-resources for automatic scope-based resource management (version 7 onwards).
|-
| Supports classes, structs ([[Plain old data structure|POD-types]]), and unions, and can allocate them on the [[Dynamic memory allocation|heap]] or the [[Stack-based memory allocation|stack]].
| Classes are allocated on the [[Dynamic memory allocation|heap]]. [[Java version history#Java SE 6 Update 14|Java SE 6]] optimizes with [[escape analysis]] to allocate some objects on the [[Stack-based memory allocation|stack]].
|-
| Allows explicitly overriding types as well as some implicit narrowing conversions (for compatibility with C).
| Rigid [[type safety]] except for widening conversions.
|-
| The [[C++ Standard Library]] was designed to have a limited scope and functionality but includes language support, diagnostics, general utilities, strings, locales, containers, algorithms, [[Iterator#C++|iterators]], numerics, input/output, random number generators, regular expression parsing, threading facilities, type traits (for static type introspection) and Standard C Library. The [[Boost (C++ libraries)|Boost library]] offers more functionality including network I/O.
A rich amount of third-party libraries exist for GUI and other functionalities like: [[Adaptive Communication Environment|ACE]], [[Crypto++]], various [[XMPP]] [[Instant Messaging]] (IM) libraries,<ref name="XMPP Software » Libraries">{{cite web|title=XMPP Software » Libraries|url=http://xmpp.org/xmpp-software/libraries/|publisher=xmpp.org|accessdate=13 June 2013}}</ref> [[OpenLDAP]], [[Qt (framework)|Qt]], [[gtkmm]].
| The standard library has grown with each release. By version 1.6, the library included support for locales, logging, containers and iterators, algorithms, GUI programming (but not using the system GUI), graphics, multi-threading, networking, platform security, introspection, dynamic class loading, blocking and non-blocking I/O. It provided interfaces or support classes for [[XML]], [[XSLT]], [[MIDI]], database connectivity, naming services (e.g. [[LDAP]]), cryptography, security services (e.g. [[Kerberos (protocol)|Kerberos]]), print services, and web services. SWT offers an abstraction for platform-specific GUIs.
|-
| [[Operator overloading]] for most operators. Preserving meaning (semantics) is highly recommended.
| Operators are not overridable. The language overrides + and += for the String class.
|-
| Single and [[Multiple inheritance]] of classes, including virtual inheritance.
| Single inheritance of classes. Supports multiple inheritance via the [[Interface (Java)|Interfaces]] construct, which is equivalent to a C++ class composed of abstract methods.
|-
| Compile-time templates. Allows for [[Turing complete]] meta-programming.
| [[Generics in Java|Generics]] are used to achieve basic type-parametrization, but they do not translate from source code to byte code due to the use of [[type erasure]] by the compiler.
|-
| Function pointers, function objects, lambdas (in [[C++11]]), and interfaces.
| References to functions achieved via the [[Reflection (computer science)|reflection]] API. OOP idioms using Interfaces, such as Adapter, Observer, and Listener are generally preferred over direct references to methods.
|-
| No standard inline documentation mechanism. Third-party software (e.g. [[Doxygen]]) exists.
| Extensive [[Javadoc]] documentation standard on all system classes and methods.
|-
| <code>const</code> keyword for defining immutable variables and member functions that do not change the object. Const-ness is propagated as a means to enforce, at compile-time, correctness of the code with respect to mutability of objects (see [[const-correctness]]).
| <code>final</code> provides a version of <code>const</code>, equivalent to <code>type* const</code> pointers for objects and <code>const</code> for primitive types. Immutability of object members achieved through read-only interfaces and object encapsulation. 
|-
| Supports the <code>[[goto]]</code> statement.
| Supports labels with loops and statement blocks.
|-
| Source code can be written to be platform-independent (can be compiled for [[Windows]], [[BSD]], [[Linux]], [[Mac OS X]], [[Solaris (operating system)|Solaris]], etc., without modification) and written to take advantage of platform-specific features. Typically compiled into native machine code, must be re-compiled for each target platform.
| Compiled into byte code for the [[JVM]]. Byte code is dependent on the Java platform, but is typically independent of [[operating system]] specific features.
|}

== Language features ==

=== Syntax ===
{{see also|Java syntax|C++ syntax}}
* [[Java syntax]] has a [[context-free grammar]] that can be parsed by a simple [[LALR parser]]. Parsing C++ is more complicated. For example, <code>Foo&lt;1&gt;(3);</code> is a sequence of comparisons if Foo is a variable, but creates an object if Foo is the name of a class template.
* C++ allows namespace-level constants, variables, and functions. In Java, such entities must belong to some given type, and therefore must be defined inside a type definition, either a class or an [[interface (Java)|interface]].
* In C++, objects are values, while in Java they are not. C++ uses ''value semantics'' by default, while Java always uses ''reference semantics''. To opt for reference semantics in C++, either a pointer or a reference can be used.

{| class="wikitable"
! style="width:600px;"| C++
! style="width:600px;"| Java
|-
| <source lang="cpp">
class Foo {          // Declares class Foo
    int x;           //  Private Member variable
public:
    Foo() : x(0)     //  Constructor for Foo; initializes
    {}               //  x to 0. If the initializer were
                     //  omitted, the variable would not
                     //  be initialized to a specific
                     //  value.

    int bar(int i) { // Member function bar()
        return 3*i + x;
    }
};</source>
| <source lang="java">
class Foo {               // Defines class Foo
    private int x;         // Member variable, normally variables
                           // are declared as private to
                           // enforce encapsulation
                          //initialized to 0 by default

    public Foo() {        // Constructor for Foo
    }

    public int bar(int i) {// Member method bar()
        return 3*i + x;
    }
}</source>
|-
| <source lang="cpp">
Foo a;
// declares a to be a Foo object value,
// initialized using the default constructor.

// Another constructor can be used as
Foo a(args);
// or (C++11):
Foo a{args};
</source>
| <source lang="java">
Foo a;
// declares a to be a reference to a Foo object
a = new Foo();
// initializes using the default constructor

// Another constructor can be used as
Foo a = new Foo(args); </source>
|-
| <source lang="cpp">
Foo b = a;
// copies the contents of a to a new Foo object b;
// alternative syntax is "Foo b(a)"</source>
| <source lang="java">
Foo b = a.clone();
// copies the contents of the object pointed to by a 
//     to a new Foo object;
// sets the reference b to point to this new object;
// the Foo class must implement the Cloneable interface
//     for this code to compile
</source>
|-
| <source lang="cpp">a.x = 5; // modifies the object a</source>
| <source lang="java">a.x = 5; // modifies the object referenced by a</source>
|-
| <source lang="cpp">
cout << b.x << endl;
// outputs 0, because b is
// a different object than a</source>
| <source lang="java">
System.out.println(b.x);
// outputs 0, because b points to
// a different object than a</source>
|-
| <source lang="cpp">
Foo *c;
// declares c to be a pointer to a
// Foo object (initially
// undefined; could point anywhere)</source>
| <source lang="java">
Foo c;
// declares c to be a reference to a Foo
// object (initially null if c is a class member;
// it is necessary to initialize c before use
// if it is a local variable)</source>
|-
| <source lang="cpp">
c = new Foo;
// binds c to reference a new Foo object</source>
| <source lang="java">
c = new Foo();
// binds c to reference a new Foo object</source>
|-
| <source lang="cpp">
Foo *d = c;
// binds d to reference the same object as c</source>
| <source lang="java">
Foo d = c;
// binds d to reference the same object as c</source>
|-
| <source lang="cpp">
c->x = 5;
// modifies the object referenced by c</source>
| <source lang="java">
c.x = 5;
// modifies the object referenced by c</source>
|-
| <source lang="cpp">
a.bar(5);  // invokes Foo::bar() for a
c->bar(5); // invokes Foo::bar() for *c
</source>
| <source lang="java">
a.bar(5); // invokes Foo.bar() for a
c.bar(5); // invokes Foo.bar() for c
</source>
|-
| <source lang="cpp">
cout << d->x << endl;
// outputs 5, because d references the
// same object as c</source>
| <source lang="java">
System.out.println(d.x);
// outputs 5, because d references the
// same object as c</source>
|}
* In C++, it is possible to declare a pointer or reference to a [[const]] object in order to prevent client code from modifying it. Functions and methods can also guarantee that they will not modify the object pointed to by a pointer by using the "const" keyword. This enforces [[const-correctness]].
* In Java, for the most part, const-correctness must rely on the semantics of the class' interface, i.e., it isn't strongly enforced, except for public data members that are labeled <code>final</code>.
{| class="wikitable"
! style="width:400px;"| C++
! style="width:400px;"| Java
|-
| <source lang="cpp">
const Foo *a; // it is not possible to modify the object
              // pointed to by a through a</source>
|<source lang="java">
final Foo a; // a declaration of a "final" reference:
             // it is possible to modify the object, 
             // but the reference will constantly point 
             // to the first object assigned to it</source>
|-
| <source lang="cpp">a = new Foo();</source>
| <source lang="java">a = new Foo(); // Only in constructor</source>
|-
| <source lang="cpp">a->x = 5;
// ILLEGAL</source>
| <source lang="java">a.x = 5;
// LEGAL, the object's members can still be modified 
// unless explicitly declared final in the declaring class</source>
|-
| <source lang="cpp">Foo *const b = new Foo();
// a declaration of a "const" pointer</source>
| <source lang="java">final Foo b = new Foo();
// a declaration of a "final" reference</source>
|-
| <source lang="cpp">b = new Foo();
//ILLEGAL, it is not allowed to re-bind it</source>
| <source lang="java">b = new Foo();
// ILLEGAL, it is not allowed to re-bind it</source>
|-
| <source lang="cpp">b->x = 5;
// LEGAL, the object can still be modified</source>
| <source lang="java">b.x = 5;
// LEGAL, the object can still be modified</source>
|}
* C++ supports <code>[[GOTO|goto]]</code> statements, which may lead to [[Spaghetti code|Spaghetti programming]]. With the exception of the goto statement (which is very rarely seen in real code and highly discouraged), both Java and C++ have basically the same [[control flow]] structures, designed to enforce [[Structured programming#Low-level structure programming|structured control flow]], and relies on [[Control flow#Early exit from loops|break and continue]] statements to provide some <code>goto</code>-like functionality. Some commenters point out that these labelled flow control statements break the single point-of-exit property of structured programming.<ref name="Martin">{{cite web|url=http://www.objectmentor.com/resources/articles/javacpp.pdf|format=PDF|title=Java vs. C++: A Critical Comparison|date=January 1997|author=Robert C. Martin}}</ref>
* C++ provides low-level features which Java lacks. In C++, pointers can be used to manipulate specific memory locations, a task necessary for writing low-level [[operating system]] components. Similarly, many C++ compilers support an [[inline assembler]]. In Java, such code must reside in external libraries, and can only be accessed through the [[Java Native Interface]], with a significant overhead for each call.

=== Semantics ===
* C++ allows default values for arguments of a function/method. Java does not. However, [[method overloading]] can be used to obtain similar results in Java but generate redundant stub code.
* The minimum of code you need to compile for C++ is a function. The minimum for Java is a class.
* C++ allows a range of implicit conversions between native types (including some narrowing conversions), and also allows the programmer to define implicit conversions involving user-defined types. In Java, only widening conversions between native types are implicit; other conversions require explicit cast syntax.
** A consequence of this is that although loop conditions (<code>if</code>, <code>while</code> and the exit condition in <code>for</code>) in Java and C++ both expect a boolean expression, code such as <code>if(a = 5)</code> will cause a compile error in Java because there is no implicit narrowing conversion from int to boolean. This is handy if the code was a typo for <code>if(a == 5)</code>. Yet current C++ compilers usually generate a warning when such an assignment is performed within a conditional expression. Similarly, standalone comparison statements, e.g. <code>a==5;</code>, without a side effect generate a warning.
* For passing parameters to functions, C++ supports both [[pass-by-reference]] and [[pass-by-value]]. In Java, primitive parameters are always passed by value. Class types, interface types, and array types are collectively called reference types in Java and are also always passed by value.<ref>{{cite web|title=Reference Types and Values|url=http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.3|work=The Java Language Specification, Third Edition|accessdate=9 December 2010}}</ref><ref>{{cite book | title = Core Java | volume = I | edition = Eighth | last1 = Horstmann | first1 = Cay | last2 = Cornell | first2 = Gary | publisher = Sun Microsystems | publication-date = 2008 | isbn = 978-0-13-235476-9 | pages = 140–141 | quote=Some programmers (and unfortunately even some book authors) claim that the Java programming language uses call by reference for objects. However, that is false. Because this is such a common misunderstanding, it is worth examining a counterexample in some detail... This discussion demonstrates that the Java programming language does not use call by reference for objects. Instead ''object references are passed by value''.}}</ref><ref>{{cite book | title = Java for Programmers | last1 = Deitel | first1 = Paul | last2 = Deitel | first2 = Harvey | publisher = Prentice Hall | publication-date = 2009 | isbn = 978-0-13-700129-3 | page = 223 | quote = Unlike some other languages, Java does not allow programmers to choose pass-by-value or pass-by-reference&mdash;all arguments are passed by value. A method call can pass two types of values to a method&mdash;copies of primitive values (e.g., values of type int and double) and copies of references to objects (including references to arrays). Objects themselves cannot be passed to methods.}}</ref>
* Java built-in types are of a specified size and range defined by the language specification. In C++, a minimal range of values is defined for built-in types, but the exact representation (number of bits) can be mapped to whatever native types are preferred on a given platform.
** For instance, Java characters are 16-bit [[Unicode]] characters, and strings are composed of a sequence of such characters. C++ offers both narrow and wide characters, but the actual size of each is platform dependent, as is the character set used. Strings can be formed from either type.
** This also implies that C++ compilers can automatically select the most efficient representation for the target platform (i.e., 64bit integers for a 64bit platform), while the representation is fixed in Java, meaning the values can either be stored in the less-efficient size, or must pad the remaining bits and add code to emulate the reduced-width behavior.
* The rounding and precision of floating point values and operations in C++ is implementation-defined (although only very exotic or old platforms depart from the [[IEEE 754]] standard). Java provides an optional [[strictfp|strict floating-point model]] that guarantees more consistent results across platforms, though possibly at the cost of slower run-time performance, however, Java does not provide strict compliance to the IEEE 754 standard. Most C++ compilers will, by default, partially comply to IEEE 754 standard (usually excluding strict rounding rules and raise exceptions on NaN results), but provide options for stricter compliance as well as less strict compliance (to allow for some optimizations).<ref>{{cite web | url = http://gcc.gnu.org/wiki/FloatingPointMath | title = Semantics of Floating Point Math in GCC | publisher = GNU Foundation | accessdate = 20 April 2013}}</ref><ref>{{cite web | url = http://msdn.microsoft.com/en-us/library/e7s85ffb.aspx | title = Microsoft c++ compiler, /fp (Specify Floating-Point Behavior) | publisher = Microsoft Corporation | accessdate=19 March 2013}}</ref> If we label those options from least compliant to most compliant as ''fast'', ''consistent'' (Java's ''strictfp''), ''near-IEEE'', and ''strict-IEEE'', we can say that most C++ implementations default to ''near-IEEE'', with options to switch to ''fast'' or ''strict-IEEE'', while Java defaults to ''fast'' with an option to switch to ''consistent''.

* In C++, [[pointer (computer programming)|pointer]]s can be manipulated directly as memory address values. Java references are pointers to objects.<ref>{{cite web | url = http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.3.1 | title = Java Language Specification 4.3.1: Objects | publisher = Sun Microsystems | accessdate=9 December 2010}}</ref> Java references do not allow direct access to memory addresses or allow memory addresses to be manipulated with pointer arithmetic. In C++ one can construct pointers to pointers, pointers to ints and doubles, and pointers to arbitrary memory locations. Java references only access objects, never primitives, other references, or arbitrary memory locations.
* In C++, pointers can point to functions or member functions ([[function pointer]]s). The equivalent mechanism in Java uses object or interface references.
* Through the use of stack-allocated objects, C++ supports [[RAII|scoped resource management]], a technique used to automatically manage memory and other system resources that supports deterministic object destruction. While scoped resource management in C++ cannot be guaranteed (even objects with proper destructors can be allocated using <code>new</code> and left undeleted) it provides an effective means of resource management. Shared resources can be managed using <code>shared_ptr</code>, along with <code>weak_ptr</code> to break cyclic references. Java supports automatic memory management using [[garbage collection (computer science)|garbage collection]] which can free unreachable objects even in the presence of cyclic references, but other system resources (files, streams, windows, communication ports, threads, etc.) must be explicitly released because garbage collection is not guaranteed to occur immediately after the last object reference is abandoned.
* C++ features user-defined [[operator overloading]]. Operator overloading allows for user-defined types to support operators (arithmetic, comparisons, etc.) like primitive types via user-defined implementations for these operators. It is generally recommended to preserve the semantics of the operators. Java does not support any form of operator overloading (although its library uses the addition operator for string concatenation).
* Java features standard [[Application programming interface|API]] support for [[reflection (computer science)|reflection]] and [[dynamic loading]] of arbitrary new code.
* C++ supports static and dynamic linking of binaries.
* Java has [[Generic programming#Generics in Java|generics]], whose main purpose is to provide type-safe containers. C++ has compile-time [[Generic programming#Templates in C++|templates]], which provide more extensive support for generic programming and metaprogramming. Java has [[Java annotation|annotations]], which allow adding arbitrary custom metadata to classes and metaprogramming via an [[Annotation processing tool#Java|annotation processing tool]].
* Both Java and C++ distinguish between native types (these are also known as "fundamental" or "built-in" types) and user-defined types (these are also known as "compound" types). In Java, native types have value semantics only, and compound types have reference semantics only. In C++ all types have value semantics, but a reference can be created to any type, which will allow the object to be manipulated via reference semantics.
* C++ supports [[multiple inheritance]] of arbitrary classes. In Java a class can derive from only one class, but a class can implement multiple [[Interface (Java)|interface]]s (in other words, it supports multiple inheritance of types, but only single inheritance of implementation).
* Java explicitly distinguishes between interfaces and classes. In C++, multiple inheritance and pure virtual functions make it possible to define classes that function almost like Java interfaces do, with a few small differences.
* Java has both language and standard library support for [[Thread (computer science)|multi-threading]]. The <code>synchronized</code> [[Java keywords|keyword in Java]] provides simple and secure [[mutual exclusion|mutex lock]]s to support multi-threaded applications. Java also provides robust and complex libraries for more advanced multi-threading synchronization. Only as of [[C++11]] is there a defined memory model for multi-threading in C++, as well as library support for creating threads and for many synchronization primitives. There are also many third-party libraries for this purpose.
* C++ member functions can be declared as [[virtual function]]s, which means the method to be called is determined by the run-time type of the object (a.k.a. dynamic dispatching). By default, methods in C++ are not virtual (i.e., ''opt-in virtual''). In Java, methods are virtual by default, but can be made non-virtual by using the [[final (Java)|<code>final</code> keyword]] (i.e., ''opt-out virtual'').
* C++ enumerations are primitive types and support implicit conversion to integer types (but not from integer types). Java enumerations can be <code>public static enum{enumName1,enumName2}</code> and are used like classes. Another way is to make another class that extends <code>java.lang.Enum<E></code>) and may therefore define constructors, fields, and methods as any other class. As of [[C++11]], C++ also supports [[C++11#Strongly typed enumerations|strongly-typed enumerations]] which provide more type-safety and explicit specification of the storage type.
* Unary operators '++' and '--': in C++ "The operand shall be a modifiable [[Value (computer science)|lvalue]]. [skipped] The result is the updated operand; it is an lvalue...",<ref>Standard for Programming Language C++ '11, 5.3.2 Increment and decrement [expr.pre.incr].</ref> but in Java "the binary numeric promotion mentioned above may include unboxing conversion and value set conversion. If necessary, value set conversion {and/or [...] boxing conversion} is applied to the sum prior to its being stored in the variable.",<ref>The Java™ Language Specification, Java SE 7 Edition, Chapters 15.14.2 , 15.14.3, 15.15.1, 15.15.2, http://docs.oracle.com/javase/specs/</ref> i.e. in Java, after the initialization "Integer i=2;", "++i;" changes the reference i by assigning new object, while in C++ the object is still the same.

=== Resource management ===
* Java offers automatic [[garbage collection (computer science)|garbage collection]], which may be bypassed in specific circumstances via the [[Real time Java]] specification. Memory management in C++ is usually done through constructors, destructors, and [[smart pointer]]s. The C++ standard permits garbage collection, but does not require it; garbage collection is rarely used in practice.
* C++ can allocate arbitrary blocks of memory. Java only allocates memory through object instantiation. Arbitrary memory blocks may be allocated in Java as an array of bytes. 
* Java and C++ use different idioms for resource management. Java relies mainly on garbage collection, which can reclaim memory, while C++ relies mainly on the [[Resource Acquisition Is Initialization|RAII (Resource Acquisition Is Initialization)]] idiom. This is reflected in several differences between the two languages:
** In C++ it is common to allocate objects of compound types as local stack-bound variables which are destroyed when they go out of scope. In Java compound types are always allocated on the heap and collected by the garbage collector (except in virtual machines that use [[escape analysis]] to convert heap allocations to stack allocations).
** C++ has destructors, while Java has [[finalizer]]s. Both are invoked prior to an object's deallocation, but they differ significantly. A C++ object's destructor must be implicitly (in the case of stack-bound variables) or explicitly invoked to deallocate the object. The destructor executes [[Synchronization|synchronously]] just prior to the point in the program at which the object is deallocated. Synchronous, coordinated uninitialization and deallocation in C++ thus satisfy the RAII idiom. In Java, object deallocation is implicitly handled by the garbage collector. A Java object's finalizer is invoked [[asynchrony|asynchronously]] some time after it has been accessed for the last time and before it is actually deallocated. Very few objects require finalizers; a finalizer is only required by objects that must guarantee some cleanup of the object state prior to deallocation &mdash; typically releasing resources external to the JVM. 
** With RAII in C++, a single type of resource is typically wrapped inside a small class that allocates the resource upon construction and releases the resource upon destruction, and provide access to the resource in between those points. Any class that contain only such RAII objects do not need to define a destructor since the destructors of the RAII objects are called automatically as an object of this class is destroyed. In Java, safe synchronous deallocation of resources can be performed deterministically using the try/catch/finally construct.
** In C++, it is possible to have a [[dangling pointer]]—a stale [[reference (computer science)|reference]] to an object that has already been deallocated. Attempting to use a dangling pointer typically results in program failure. In Java, the garbage collector will not destroy a referenced object.
** In C++, it is possible to have uninitialized primitive objects. Java enforces default initialization.
** In C++, it is possible to have an allocated object to which there is no valid reference. Such an [[unreachable object]] cannot be destroyed (deallocated), and results in a [[memory leak]]. In contrast, in Java an object will not be deallocated by the garbage collector ''until'' it becomes unreachable (by the user program). (Note: ''[[weak reference]]s'' are supported, which work with the Java garbage collector to allow for different ''strengths'' of reachability.) Garbage collection in Java prevents many memory leaks, but leaks are still possible under some circumstances.<ref>{{cite web|url=http://www-128.ibm.com/developerworks/rational/library/05/0816_GuptaPalanki/ |title=Java memory leaks -- Catch me if you can |authors=Satish Chandra Gupta, Rajeev Palanki|publisher=IBM DeveloperWorks |date=16 August 2005 |accessdate=2015-04-02|archiveurl=http://web.archive.org/web/20120722095536/http://www.ibm.com/developerworks/rational/library/05/0816_GuptaPalanki/|archivedate=2012-07-22}}</ref><ref>[http://web.archive.org/web/20140205030750/http://www.openlogic.com/wazi/bid/188158 How to Fix Memory Leaks in Java] by Veljko Krunic (Mar 10, 2009)</ref><ref>[http://stackoverflow.com/questions/6470651/creating-a-memory-leak-with-java Creating a memory leak with Java] on [[stackoverflow]].com</ref>

=== Libraries ===
* C++ provides [[cross-platform]] access to many features typically available in platform-specific libraries. Direct access from Java to native operating system and hardware functions requires the use of the [[Java Native Interface]].

=== Runtime ===

{| class="wikitable"
! style="width:50%;"| C++
! style="width:50%;"| Java
|-
| C++ is compiled directly to [[machine code]] which is then executed directly by the [[central processing unit]]. 
| Java is compiled to [[byte-code]] which the [[Java virtual machine]] (JVM) then [[interpreter (computing)|interprets]] at runtime. Actual Java implementations do [[Just-in-time compilation]] to native machine code. Alternatively, the [[GNU Compiler for Java]] can compile directly to machine code.
|-
|}
* Due to its unconstrained expressiveness, low level C++ language features (e.g. unchecked array access, raw pointers, [[type punning]]) cannot be reliably checked at compile-time or without overhead at run-time. Related programming errors can lead to low-level [[buffer overflow]]s and [[segmentation fault]]s. The [[Standard Template Library]] provides higher-level RAII abstractions (like vector, list and map) to help avoid such errors. In Java, low level errors either cannot occur or are detected by the [[Java virtual machine|JVM]] and reported to the application in the form of an [[exception handling|exception]].
* The Java language requires specific behavior in the case of an out-of-bounds array access, which generally requires [[bounds checking]] of array accesses. This eliminates a possible source of instability but usually at the cost of slowing down execution. In some cases, especially since Java 7, [[compiler analysis]] can prove a bounds check unnecessary and eliminate it. C++ has no required behavior for out-of-bounds access of native arrays, thus requiring no bounds checking for native arrays. C++ standard library collections like std::vector, however, offer optional bounds checking. In summary, Java arrays are "usually safe; slightly constrained; often have overhead" while C++ native arrays "have optional overhead; are slightly unconstrained; are possibly unsafe."

=== Templates vs. generics ===
Both C++ and Java provide facilities for [[generic programming]], [[template (programming)|template]]s and [[Generics in Java|generics]], respectively. Although they were created to solve similar kinds of problems, and have similar syntax, they are actually quite different.

:{| class="wikitable"
! C++ Templates
! Java Generics
|-
| Classes, functions, alisases<ref>http://en.cppreference.com/w/cpp/language/type_alias</ref> and variables<ref>http://en.cppreference.com/w/cpp/language/variable_template</ref> can be templated.
| Classes and methods can be genericized.
|-
| Parameters can be variadic, of any type, integral value, character literal, or a class template.
| Parameters can be any reference type, including boxed primitive types (i.e. Integer, Boolean...).
|-
| Separate instantiations of the class or function will be generated for each parameter-set when compiled. For class templates, only the member functions that are used will be instantiated.
| One version of the class or function is compiled, works for all type parameters (through type-erasure).
|-
| Objects of a class template instantiated with different parameters will have different types at run time (i.e., distinct template instantiations are distinct classes).
| Type parameters are erased when compiled; objects of a class with different type parameters are the same type at run time. It just causes a different constructor. Because of this type erasure, it is not possible to overload methods using different instantiations of the generic class. 
|-
| Implementation of the class or function template must be visible within a translation unit in order to use it. This usually implies having the definitions in the header files or included in the header file. As of [[C++11]], it is possible to use [[C++11#Extern template|extern templates]] to separate the compilation of certain instantiations.
| Signature of the class or function from a compiled class file is sufficient to use it.
|-
| Templates can be [[Template (programming)#Explicit template specialization|specialized]]—a separate implementation could be provided for a particular template parameter.
| Generics cannot be specialized.
|-
| Template parameters can have [[default argument]]s. (Prior to [[C++11]], this was allowed only for template classes, not functions.)
| Generic type parameters cannot have default arguments.
|-
| Does not support wildcards. Instead, return types are often available as nested typedefs. (Also, [[C++11]] added keyword <code>auto</code>, which acts as a wildcard for any type that can be determined at compile time.)
| Supports wildcard as type parameter.
|-
| Does not directly support bounding of type parameters, but metaprogramming provides this<ref>[http://www.boost.org/libs/type_traits/doc/html/boost_typetraits/reference.html Boost type traits library<!-- Bot generated title -->]</ref>
| Supports bounding of type parameters with "extends" and "super" for upper and lower bounds, respectively; allows enforcement of relationships between type parameters.
|-
| Allows instantiation of an object with the type of the parameter type.
| Does not allow instantiation of an object with the type of the parameter type (except through reflection).
|-
| Type parameter of class template can be used for static methods and variables.
| Type parameter of generic class cannot be used for static methods and variables.
|-
| Static variables are not shared between classes and functions of different type parameters.
| Static variables are shared between instances of classes of different type parameters.
|-
| Class and function templates do not enforce type relations for type parameters in their declaration. Use of an incorrect type parameter results in compilation failure, often generating an error message within the template code rather than in the user's code that invokes it. Proper use of templated classes and functions is dependent on proper documentation. Metaprogramming provides these features at the cost of additional effort. There was a proposition to solve this problem in [[C++11]], so-called [[Concepts (C++)|Concepts]], it is now planned for the next standard.
| Generic classes and functions can enforce type relationships for type parameters in their declaration. Use of an incorrect type parameter results in a type error within the code that uses it. Operations on parametrized types in generic code are only allowed in ways that can be guaranteed to be safe by the declaration. This results in greater type safety at the cost of flexibility.
|-
| Templates are [[Turing-complete]] (see [[template metaprogramming]]).
| Generics are probably not Turing-complete.
|}

=== Miscellaneous ===
* Java and C++ use different techniques for splitting up code in multiple source files. Java uses a package system that dictates the file name and path for all program definitions. In Java, the compiler imports the executable [[class (file format)|class files]]. C++ uses a [[header file]] [[source code]] inclusion system for sharing declarations between source files.
* Compiled Java code files are generally smaller than code files in C++ as [[Java bytecode]] is usually more compact than native [[machine code]] and Java programs are never statically linked.
* C++ compilation features an additional textual [[preprocessor|preprocessing]] phase, while Java does not. Thus some users add a preprocessing phase to their build process for better support of conditional compilation.
* Java's division and modulus operators are well defined to truncate to zero. C++ (prior to [[C++11]]) does not specify whether or not these operators truncate to zero or "truncate to -infinity". -3/2 will always be -1 in Java and C++11, but a [[C++03]] compiler may return either -1 or -2, depending on the platform. [[C99]] defines division in the same fashion as Java and C++11. Both languages guarantee (where a and b are integer types) that <code>(a/b)*b + (a%b) == a</code> for all a and b (b != 0). The [[C++03]] version will sometimes be faster, as it is allowed to pick whichever truncation mode is native to the processor.
* The sizes of integer types are defined in Java (int is 32-bit, long is 64-bit), while in C++ the size of integers and pointers is compiler and [[Application binary interface|ABI]] dependent within given constraints. Thus, carefully written C++ code can take advantage of the 64-bit processor's capabilities while still functioning properly on 32-bit processors. In contrast, Java's fixed integer sizes may incur a performance penalty since Java code cannot run using an arbitrary processor's word size.

An example comparing [http://en.wikibooks.org/wiki/C%2B%2B_Programming/Code/IO#.E2.80.8ERounding_number_example C++] and [http://en.wikibooks.org/wiki/Java_Programming/Mathematical_functions#Rounding_number_example Java] exists in [[Wikibooks]].

== Performance ==
{{Refimprove section|date=September 2010}}

In addition to running a compiled Java program, computers running Java applications generally must also run the [[Java virtual machine]] (JVM), while compiled C++ programs can be run without external applications. Early versions of Java were significantly outperformed by statically compiled languages such as C++. This is because the program statements of these two closely related languages may compile to a few machine instructions with C++, while compiling into several byte codes involving several machine instructions each when interpreted by a JVM. For example:
{| class="wikitable"
! Java/C++ statement
! C++ generated code (x86)
! Java generated byte code
|-
| vector[i]++;
| mov edx,[ebp+4h]<br/>
mov eax,[ebp+1Ch]<br/>
inc dword ptr [edx+eax*4]
| aload_1<br/>
iload_2<br/>
dup2<br/>
iaload<br/>
iconst_1<br/>
iadd<br/>
iastore
|}

Since performance optimization is a very complex issue, it is very difficult to quantify the performance difference between C++ and Java in general terms, and most benchmarks are unreliable and biased. And given the very different natures of the languages, definitive qualitative differences are also difficult to draw. In a nutshell, there are inherent inefficiencies as well as hard limitations on optimizations in Java given that it heavily relies on flexible high-level abstractions, however, the use of a powerful JIT compiler (as in modern JVM implementations) can mitigate some issues. And, in any case, if the inefficiencies of Java are too much to bear, compiled C or C++ code can be called from Java by means of the JNI.

Certain inefficiencies that are inherent to the Java language itself include, primarily:

* All objects are allocated on the heap. For functions using small objects this can result in performance degradation and heap fragmentation, while stack allocation, in contrast, costs essentially zero. However, modern JIT compilers mitigate this problem to some extent with escape analysis or escape detection to allocate objects on the stack, since Oracle JDK 6.
* Methods are virtual by default (although they can be made final), usually leading to an abuse of virtual methods, adding a level of indirection to every call. This also slightly increases memory usage by adding a single pointer to a virtual table per each object. It also induces a start-up performance penalty, since a JIT compiler must perform additional optimization passes for de-virtualization of small functions.
* A lot of run-time casting required even using standard containers induces a performance penalty. However, most of these casts are statically eliminated by the JIT compiler.
* Safety guarantees come at a run-time cost. For example, the compiler is required to put appropriate range checks in the code. Guarding each array access with a range check is not efficient, so most JIT compilers will try to eliminate them statically or by moving them out of inner loops (although most native compilers for C++ will do the same when range-checks are optionally used).
* Lack of access to low-level details prevents the developer from improving the program where the compiler is unable to do so.<ref>{{cite journal | first =Nathan | last = Clark |author2=Amir Hormati |author3=Sami Yehia |author4=Scott Mahlke
 | title = Liquid SIMD: Abstracting SIMD hardware using lightweight dynamic mapping | journal = HPCA’07 | pages=216–227 | year = 2007}}</ref>
* The mandatory use of reference-semantics for all user-defined types in Java can introduce large amounts of superfluous memory indirections (or jumps) (unless elided by the JIT compiler) which can lead to frequent cache misses (a.k.a. [[Thrashing (computer science)|cache thrashing]]). Furthermore, cache-optimization, usually via cache-aware or [[Cache-oblivious algorithm|cache-oblivious]] data structures and algorithms, can often lead to orders of magnitude improvements in performance as well as avoiding time-complexity degeneracy that is characteristic of many cache-pessimizing algorithms, and is therefore one of the most important forms of optimization; reference-semantics, as mandated in Java, makes such optimizations impossible to realize in practice (by neither the programmer nor the JIT compiler).
* [[garbage collection (computer science)|Garbage collection]],<ref name="hundt2011">{{cite web| last=Hundt | first=Robert  |title=Loop Recognition in C++/Java/Go/Scala | publisher=[[Scala Days]] 2011 | date=2011-04-27|location=Stanford, California | accessdate=2012-11-17 | url=https://days2011.scala-lang.org/sites/days2011/files/ws3-1-Hundt.pdf |quote=''Java shows a large GC component, but a good code performance. [...] We find that in regards to performance, C++ wins out by a large margin. [...] The Java version was probably the simplest to implement, but the hardest to analyze for performance. Specifically the effects around garbage collection were complicated and very hard to tune'' | format=PDF; 318&nbsp;kB}}</ref> as this form of automatic memory management introduces memory overhead.<ref name="HertzBerger2005">{{cite web|url=http://people.cs.umass.edu/~emery/pubs/gcvsmalloc.pdf |title=Quantifying the Performance of Garbage Collection vs. Explicit Memory Management |author=Matthew Hertz, Emery D. Berger |publisher=OOPSLA 2005 |date=2005 |accessdate=2015-03-15 |quote=''In particular, when garbage collection has five times as much memory as required, its runtime performance matches or slightly exceeds that of explicit memory management. However, garbage collection’s performance degrades substantially when it must use smaller heaps. With three times as much memory, it runs 17% slower on average, and with twice as much memory, it runs 70% slower.''}}</ref>

However, there are a number of benefits to Java's design, some realized, some only theorized:

* Java [[garbage collection (computer science)|garbage collection]] may have better cache coherence than the usual usage of ''[[malloc]]''/''[[new (C++)|new]]'' for memory allocation. Nevertheless, arguments exist{{Weasel-inline|date=March 2012}} that both allocators equally fragment the heap and neither exhibits better cache locality. However, in C++, allocation of single objects on the heap is rare, and large quantities of single objects are usually allocated in blocks via an STL container and/or with a small object allocator.<ref>{{cite book | first = Andrei | last = Alexandrescu | title = Modern C++ Design: Generic Programming and Design Patterns Applied. Chapter 4 | editor = Addison-Wesley | pages=77–96 | year = 2001 | ISBN = 978-0-201-70431-0}}</ref><ref>{{cite web | url = http://www.boost.org/doc/libs/release/libs/pool/ | title = Boost Pool library | publisher = Boost | accessdate=19 April 2013 }}</ref>
* Run-time compilation can potentially use information about the platform on which the code is being executed to improve code more effectively. However, most state-of-the-art native (C, C++, etc.) compilers generate multiple code paths to employ the full computational abilities of the given system.<ref>[http://www.slac.stanford.edu/comp/unix/.../icc/.../optaps_dsp_qax.htm Targeting IA-32 Architecture Processors for Run-time Performance Checking]</ref> Additionally, the inverse argument can be made that native compilers can better exploit architecture-specific optimizations and instruction sets than multi-platform JVM distributions.
* Run-time compilation allows for more aggressive virtual function inlining than is possible for a static compiler, because the JIT compiler has more information about all possible targets of virtual calls, even if they are in different dynamically loaded modules. Currently available JVM implementations have no problem in inlining most of the monomorphic, mostly monomorphic and dimorphic calls, and research is in progress to inline also megamorphic calls, thanks to the recent invoke dynamic enhancements added in Java 7.<ref>[http://www.azulsystems.com/blog/cliff/2011-04-04-fixing-the-inlining-problem Fixing The Inlining “Problem” by Dr. Cliff Click | Azul Systems: Blogs<!-- Bot generated title -->]</ref> Inlining can allow for further optimisations like loop vectorisation or [[loop unwinding|loop unrolling]], resulting in a huge overall performance increase.
* In Java, thread synchronization is built into the language, so the JIT compiler can potentially, through escape analysis, elide locks,<ref>[http://java.sun.com/performance/reference/whitepapers/6_performance.html#2.1.2 Oracle Technology Network for Java Developers<!-- Bot generated title -->]</ref> significantly improving performance of naive multi-threaded code. This technique was introduced in Sun JDK 6 update 10 and is named biased locking.<ref>[http://java.sun.com/performance/reference/whitepapers/6_performance.html#2.1.1 Oracle Technology Network for Java Developers<!-- Bot generated title -->]</ref>

Additionally, some performance problems exist in C++ as well:

* Allowing pointers to point to any address can make optimization difficult due to the possibility of interference between pointers that alias each other. However, the introduction of ''strict-aliasing'' rules largely solves this problem.<ref>[http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html Understanding Strict Aliasing - CellPerformance<!-- Bot generated title -->]</ref>
* Since the code generated from various instantiations of the same class template in C++ is not shared (as with type-erased generics in Java), excessive use of templates may lead to significant increase of the executable code size (a.k.a. [[code bloat]]). However, because function templates are aggressively inlined, they can sometimes reduce code bloat but more importantly allow for more aggressive static analysis and code optimization by the compiler, more often making them more efficient than non-templated code, while, by contrast, Java generics are necessarily less efficient than non-genericized code.
* Because dynamic linking is performed after code generation and optimization in C++, function calls spanning different dynamic modules cannot be inlined.
* Because thread support is generally provided by libraries in C++, C++ compilers cannot perform thread-related optimizations. However, since the introduction of multi-threading memory models in [[C++11]], modern compilers have the necessary language features to implement such optimizations. Furthermore, many optimizing compilers, such as the Intel compiler, provide several language extensions and advanced threading facilities for professional multi-threading development.

== Official standard and reference of the language ==

=== Language specification ===
The C++ language is defined by ''ISO/IEC 14882'', an [[International Organization for Standardization|ISO]] standard, which is published by the ''ISO/IEC JTC1/SC22/WG21'' committee. The latest, post-standardization draft of [[C++11]] is available as well.<ref>{{cite web | title=Working Draft, Standard for Programming Language C++ | url=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf}}</ref>

The C++ language evolves through an open steering committee called the C++ Standards Committee. The committee is composed of the creator of C++ [[Bjarne Stroustrup]], the convener [[Herb Sutter]], and other prominent figures, including many representatives of industries and user-groups (i.e., the stake-holders). Being an open committee, anyone is free to join, participate, and contribute proposals for upcoming releases of the standard and technical specifications. The committee now aims to release a new standard every few years, although in the past strict review processes and discussions have meant longer delays between publication of new standards (1998, 2003, and 2011).

The Java language is defined by the ''Java Language Specification'',<ref>[http://java.sun.com/docs/books/jls/ The Java Language Specification]</ref> a book which is published by Oracle.

The Java language continuously evolves through a process called the [[Java Community Process]], and the world's programming community is represented by a group of people and organizations - the Java Community members<ref>[http://www.jcp.org/en/participation/members The Java Community Process(SM) Program - Participation - JCP Members<!-- Bot generated title -->]</ref>—which is actively engaged into the enhancement of the language, by sending public requests - the Java Specification Requests - which must pass formal and public reviews before they get integrated into the language.

The lack of a firm standard for Java and the somewhat more volatile nature of its specifications have been a constant source of criticism by stake-holders wanting more stability and more conservatism in the addition of new language and library features. On the other hand, C++ committee also receives constant criticism for the opposite reason, i.e., being too strict and conservative, and taking too long to release new versions.

=== Trademarks ===
"C++" is not a trademark of any company or organization and is not owned by any individual.<ref>[http://www.research.att.com/~bs/bs_faq.html#revenues Bjarne Stroustrup's FAQ: Do you own C++?]</ref>
"Java" is a trademark of [[Oracle Corporation]].<ref>[http://blogs.zdnet.com/BTL/?p=16598 ZDNet: Oracle buys Sun; Now owns Java].</ref>

== References ==
{{reflist|2}}

== External links ==
{{wikibooks|C++ Programming|Programming Languages/Comparisons/Java}}
* [http://task3.cc/98/object-oriented-memory-management Object Oriented Memory Management: Java vs. C++]
* [http://www.ora.com/catalog/javanut/excerpt/index.html Chapter 2:How Java Differs from C], chapter from [[Java in a Nutshell]] by [[David Flanagan]]
* [http://www.fatalmind.com/papers/java_vs_cplusplus/resource.html Java vs. C++ resource management comparison] - Comprehensive paper with examples
* [http://www.azulsystems.com/blog/cliff-click/2009-09-06-java-vs-c-performanceagain Java vs C performance... again...] - In-depth discussion of differences between Java and C / C++ with regard to performance.
{{use dmy dates|date=January 2012}}

{{DEFAULTSORT:Comparison Of Java And C Plus Plus}}
[[Category:Programming language comparisons|Java and C++]]
[[Category:Java (programming language)]]
[[Category:C++]]
