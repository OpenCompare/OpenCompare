<html>
  <head>
    <meta charset="utf-8"/>
  </head>
  <body>
    <div>
      <h1>Main paradigm approaches</h1>
      <table border="1">
        <tr>
          <td> Paradigm </td>
          <td> Description </td>
          <td> Main characteristics </td>
          <td> Related paradigm(s) </td>
          <td> Critics </td>
          <td> Examples </td>
        </tr>
        <tr>
          <td> Imperative </td>
          <td>
            Computation as statements that directly change a program state (datafields)
          </td>
          <td> Direct assignments, common data structure, global variable </td>
          <td> </td>
          <td> Edsger W. Dijkstra, Michael A. Jackson </td>
          <td> C, C++, Java, PHP, Python </td>
        </tr>
        <tr>
          <td> Structured </td>
          <td>
            A style of imperative programming with more logical program structure
          </td>
          <td>
            Structogram, indentation, either no, or limited use of, goto statements
          </td>
          <td> Imperative </td>
          <td> </td>
          <td> C, C++, Java, Python </td>
        </tr>
        <tr>
          <td> Procedural </td>
          <td>
            Derived from structured programming, based on the concept of modular programming or the procedure call
          </td>
          <td> Local variable, sequence, selection, iteration, and modularization </td>
          <td> Structured, imperative </td>
          <td> </td>
          <td> C, C++, Lisp, PHP, Python </td>
        </tr>
        <tr>
          <td> Functional </td>
          <td>
            Treats computation as the evaluation of mathematical functions avoiding state and mutable data
          </td>
          <td>
            Lambda calculus, compositionality, formula, recursion, referential transparency, no side effects
          </td>
          <td> Declarative </td>
          <td> </td>
          <td> Erlang, Haskell, Lisp, Clojure, Scala, SML, F#, SequenceL, Python </td>
        </tr>
        <tr>
          <td> Event-driven including time driven </td>
          <td>
            Program flow is determined mainly by events, such as mouse click or interrupts including timer
          </td>
          <td> Main loop, event handlers, asynchronous processes </td>
          <td> Procedural, dataflow </td>
          <td> </td>
          <td> ActionScript </td>
        </tr>
        <tr>
          <td> Object-oriented </td>
          <td>
            Treats datafields as objects manipulated through pre-defined methods only
          </td>
          <td>
            Objects, methods, message passing, information hiding, data abstraction, encapsulation, polymorphism, inheritance, serialization-marshalling
          </td>
          <td> </td>
          <td> See here and </td>
          <td> Common Lisp, C++, C#, Eiffel, Java, PHP, Python, Ruby, Scala </td>
        </tr>
        <tr>
          <td> Declarative </td>
          <td> Defines computation logic without defining its detailed control flow </td>
          <td> 4GL, spreadsheet, report program generator </td>
          <td> </td>
          <td> </td>
          <td> SQL, regular expressions, CSS, Prolog </td>
        </tr>
        <tr>
          <td> Automata-based programming </td>
          <td>
            Treats programs as a model of a finite state machine or any other formal automata
          </td>
          <td>
            State enumeration, control variable, state changes, isomorphism, state transition table
          </td>
          <td> Imperative, event-driven </td>
          <td> </td>
          <td> </td>
        </tr>
        <tr>
          <td> Paradigm </td>
          <td> Description </td>
          <td> Main characteristics </td>
          <td> Related paradigm(s) </td>
          <td> Critics? </td>
          <td> Examples </td>
        </tr>
      </table>
    </div>
    <div>
      <h1>Differences in terminology</h1>
      <table border="1">
        <tr>
          <td> “ </td>
          <td>
            &quot;You can know the name of a bird in all the languages of the world, but when you're finished, you'll know absolutely nothing whatever about the bird... So let's look at the bird and see what it's doing-- that's what counts. I learned very early the difference between knowing the name of something and knowing something.
          </td>
          <td> ” </td>
        </tr>
        <tr>
          <td>   </td>
          <td> </td>
          <td> /!\ Not defined /!\ </td>
        </tr>
      </table>
    </div>
    <div>
      <h1>Pseudocode examples comparing various paradigms</h1>
      <table border="1">
        <tr>
          <td> Imperative </td>
          <td> Procedural </td>
          <td> Object-oriented </td>
        </tr>
        <tr>
          <td> </td>
          <td> </td>
          <td> </td>
        </tr>
      </table>
    </div>
  </body>
</html>