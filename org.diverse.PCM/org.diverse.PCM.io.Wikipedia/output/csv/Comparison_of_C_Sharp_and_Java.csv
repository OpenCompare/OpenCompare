"Data types","Java","C#"
"Single-root (unified) type system","No; but wrapper types","Yes"
"Signed integers","Yes; 8, 16, 32, 64 bits","Yes; 8, 16, 32, 64 bits"
"Unsigned integers","No; but some method support.","Yes; 8, 16, 32, 64 bits"
"Character","Yes","Yes"
"Date/time","Yes; reference type","Yes; value type"
"IEEE 754 binary32 floating point number","Yes","Yes"
"IEEE 754 binary64 floating point number","Yes","Yes"
"Boolean type","Yes","Yes"
"High precision decimal number","No; but see 'Arbitrary size decimals' below","128-bit (28 digits) Decimal type"
"Arbitrary size decimals","Reference type; no operators","No"
"Strings","Immutable reference type, Unicode","Immutable reference type, Unicode"
"Arbitrary size integers","Reference type; no operators","Yes"
"Complex numbers","No","Yes"
"Reference types","Yes","Yes"
"Arrays","Yes","Yes"
"Value types","No; only primitive types","Yes"
"Type annotations","Yes","Yes"
"Enumerated types","Yes; reference type","Yes; scalar"
"Lifted (nullable) types","No; but wrapper types","Yes"
"Tuples","No; limited 3rd party available.","Yes"
"Pointers","No; only method references","Yes"
"","Java","C#"
"Definition","In Java, the enumeration type is a class, and its values are objects (instances) of that class. The only valid values are the ones listed in the enumeration. The enumeration type may declare fields, allowing each individual enumerated value to reference additional data associated uniquely with that specific value. The enumeration type may also declare or override methods, or implement interfaces.","Enumeration in C# are implicitly derived from the  type that again is a value type derivative. The value set of a C# enumeration is defined by the underlying type that can be a signed or unsigned integer type of 8, 16, 32 or 64 bits. The enumeration definition defines names for the selected integer values. By default the first name is assigned the value 0 (zero) and the following names are assigned in increments of 1. Any value of the underlying primitive type is a valid value of the enumeration type, though an explicit cast may be needed to assign it."
"Combining","Java enumeration set and map collections provide functionality to combine multiple enumeration values to a combined value. These special collections allows compiler optimization to minimize the overhead incurred by using collections as the combination mechanism.","C# supports bit-mapped enumerations where an actual value may be a combination of enumerated values bitwise or'ed together. The formatting and parsing methods implicitly defined by the type will attempt to use these values."
"Reference types","Java","C#"
"Garbage collection","Yes","Yes"
"Weak reference","Yes","Yes"
"Reference queue (interaction with garbage collection)","Yes","Yes"
"Soft and Phantom references","Yes","No"
"Proxy support","Yes; proxy generation","Yes; object contexts"
"Object orientation","Java","C#"
"Classes","mandatory","mandatory"
"Interfaces","Yes","Yes"
"Abstract classes","Yes","Yes"
"Member accessibility levels","Yes; public, package, protected, private","Yes; public, internal, protected, private, protected internal"
"Class-level inner classes","Yes; inner classes are class level","Yes; all inner classes are class level"
"Instance-level inner classes","Yes","No"
"Statement-level (local) anonymous classes","Yes","Yes; Without methods"
"Partial class","No; but see AspectJ","Yes"
"Implicit (inferred) anonymous classes","No","Yes"
"Deprecation/obsolescence","Yes","Yes"
"Overload versioning","Some","Yes"
"Enums can implement interfaces","Yes","No"
"Properties","No, but see JavaBeans spec","Yes"
"Events","Provided by standard libraries","Built-in language feature"
"Operator overloading","No","Yes"
"Indexers","No","Yes"
"Implicit conversions","No","Yes"
"Explicit conversions","No","Yes"
"Fields and initialization","Java","C#"
"Fields","Yes","Yes"
"Constants","Yes","Yes; but no support for constant passed parameters"
"Static (class) constructors","Yes","Yes"
"Instance constructors","Yes","Yes"
"Finalizers/destructors","Yes","Yes"
"Instance initializers","Yes","No; can be simulate with instance constructor"
"Object initialization","Bottom-up 
(fields and constructors)","Top-down (fields); bottom-up (constructors)"
"Object initializers","No","Yes"
"Collection initializers","No; can be modelled","Yes"
"Array initializers","Yes","Yes"
"Methods and properties","Java","C#"
"Static imports","Yes","No"
"Virtual methods","Virtual by default","Non-virtual by default"
"Abstract","Yes","Yes"
"Sealing","Yes","Yes"
"Explicit interface implementation","Default methods in Java 8","Yes"
"Value (input) parameters","Yes","Yes"
"Reference (input/output) parameters","No","Yes"
"Output (output) parameters","No","Yes"
"Constant (immutable) parameters","Yes;final parameters","No"
"Variadic methods","Yes","Yes"
"Optional arguments","No","Yes"
"Named arguments","No","Yes"
"Generator methods","No","Yes"
"Extension / default methods","Yes","Yes"
"Conditional methods","No","Yes"
"Partial methods","No","Yes"
"Java","C#"
"Generics","Java","C#"
"Implementation","Type erasure","Reification"
"Runtime realization","No","Yes"
"Covariance","Yes","Yes"
"Contravariance","Yes","Yes"
"Reference type constraint","Yes; implicit","Yes"
"Value/primitive type constraint","No","Yes"
"Constructor constraint","No","Yes"
"Relation constraint","Yes","Yes"
"Primitive/value type support","No","Yes"
"Migration compatibility","Yes","No"
"Java","C#"
"Type checks and downcasts are injected into client code (the code referencing the generics). Compared to non-generic code with manual casts, these casts will be the same, but compared to compile-time verified code that would not need runtime casts and checks, these operations represent a performance overhead.","C#/.NET generics guarantee type-safety and are verified at compile time, making extra checks/casts are unnecessary at runtime. Hence, generic code will run faster than non-generic (or type-erased) code that require casts when handling non-generic or type-erased objects."
"Cannot use primitive types as type parameters; instead, the developer must use the wrapper type corresponding to the primitive type. This incurs extra performance overhead by requiring boxing and unboxing conversions as well a memory and garbage collection pressure, as the wrappers will be heap-allocated as opposed to stack-allocated.","Primitive and value types are allowed as type parameters in generic realizations. At runtime code will be synthesized and compiled for each unique combination of type parameters upon first use. Generics that are realized with primitive/value type do not require boxing/unboxing conversions."
"Generic exceptions are not allowed and a type parameter cannot be used in a catch clause","Can both define generic exceptions and use those in catch clauses"
"Static members are shared across all generic realizations (during type erasure all realizations are folded into a single class)","Static members are separate for each generic realization. A generic realization is a unique class."
"Type parameters cannot be used in declarations of static fields/methods or in definitions of static inner classes","No restrictions on use of type parameters"
"Cannot create an array where the component type is a generic realization (concrete parameterized type)","A generic realization is a 1st class citizen and can be used as any other class; also an array component"
"Cannot create an array where the component type is a type parameter","Type parameters represent actual, discrete classes and can be used like any other type within the generic definition."
"There is no class literal for a concrete realization of a generic type","A generic realization is an actual class."
"is not allowed with type parameters or concrete generic realizations","The  and  operators work the same for type parameters as for any other type."
"Cannot create new instances using a type parameter as the type","With a constructor constraint, generic methods or methods of generic classes can create instances of classes that have default constructors."
"Type information is erased during compilation. Special extensions to reflection must be used to discover the original type.","Type information about C# generic types is fully preserved at runtime, and allows complete reflection support as well as instantiation of generic types."
"Reflection cannot be used to construct new generic realizations. During compilation extra code (typecasts) are injected into the client code of generics. This precludes creating new realizations later.","Reflection can be used to create new realizations for new combinations of type parameters."
"Functional programming","Java","C#"
"Method references","Yes (As of Java 8)","Yes"
"Closures","All lambdas do not introduce a new level of scope. All referenced variables must be effectively final(As of Java 8)","Yes"
"Lambda expressions","Yes (As of Java 8)","Yes"
"Expression trees","No","Yes"
"Generic query language","No; but see 'Java 8 Stream' (Monad)","Yes"
"Tail recursion compiler optimizations","No","Only on x64"
"Runtime (dynamic) binding","Java","C#"
"Late-bound (dynamic) type","No","Yes"
"Runtime type information and manipulation","Java","C#"
"Runtime type information","Yes; but with type erasure","Yes"
"Runtime generics realization","No","Yes"
"Runtime type construction","No; third party tools exist","Yes"
"Statements","Java","C#"
"Loops","Yes","Yes"
"Conditionals","Yes","Yes"
"Flow control","Yes","Yes"
"Assignment","Yes","Yes"
"Exception control","Yes","Yes"
"Variable declaration","Yes","Yes"
"Variable type inference","No","Yes"
"Deterministic disposal (ARM-blocks)","Yes (starting with Java 7)","Yes"
"Expressions and operators","Java","C#"
"Arithmetic operators","Yes","Yes"
"Logical operators","Yes","Yes"
"Bitwise logic operators","Yes","Yes"
"Conditional","Yes","Yes"
"String concatenation","Yes","Yes"
"Casts","Yes","Yes"
"Boxing","Yes; implicit","Yes; implicit"
"Unboxing","Yes; implicit","Yes; explicit"
"Lifted operators","No","Yes"
"Overflow control","No","Yes"
"Strict floating point evaluation","Yes; opt-in/out","No"
"Verbatim (here-)strings","No","Yes"
"Exceptions","Java","C#"
"Checked exceptions","Yes","No"
"Try-catch-finally","Yes","Yes"
"Arrays and Collections","Java","C#"
"Abstract data type","Yes","Yes"
"One-dimensional, zero-based index arrays","Yes","Yes"
"Multidimensional arrays, rectangular (single array)","No","Yes"
"Multidimensional arrays, jagged (arrays of arrays)","Yes","Yes"
"Non-zero based arrays","No","Some"
"Unified arrays and collections","No","Yes"
"Maps/dictionaries","Yes","Yes"
"Sorted dictionaries","Yes","Yes"
"Sets","Yes","Yes"
"Sorted sets","Yes","Yes"
"Lists/vectors","Yes","Yes"
"Queues/stacks","Yes","Yes"
"Priority queue","Yes","No"
"Bags/multisets","Yes","Yes"
"Concurrency optimized collections","Yes","Yes"
"Java","C#"
"Arrays are implicitly direct specializations of . They are not unified with collection types.","Arrays in C# are implicit specializations of the  class that implements a number of collection interfaces."
"Arrays and collections are completely separate with no unification. Arrays cannot be passed where sequences or collections are expected","Arrays can be passed where sequences (s) or collections/list interfaces are expected. However, the collection operations that alter the number of elements (insert/add/remove) will throw exceptions as these operations are not supported by arrays."
"The  statement accepts either arrays or s. All collections implement . This means that the same short syntax can be used in for-loops.","The  statement iterates through a sequence using the  or interface. Because arrays always implicitly implement these interfaces, the loop will iterate through arrays as well."
"In both languages arrays are covariant. This means that a  array is assignable to variables of  because  is a specialization of (assignable to) . In both languages the arrays will perform a type check when inserting new values because type-safety would otherwise be compromised. This is in contrast to how generic collections have been implemented in both languages.","In both languages arrays are covariant. This means that a  array is assignable to variables of  because  is a specialization of (assignable to) . In both languages the arrays will perform a type check when inserting new values because type-safety would otherwise be compromised. This is in contrast to how generic collections have been implemented in both languages."
"No multidimensional arrays (rectangular arrays), but arrays of references to arrays (jagged array).","Multidimensional arrays (rectangular arrays), as well as arrays of references to arrays (jagged array)."
"Arrays cannot be resized (though use of the  method can allow for multi-step array resizing)","Arrays can be resized while preserving existing values using the  static array method."
"Implemented as a retrofit for the  library having extra features, like data structures like sets and linked sets, and has a number of algorithms to manipulate elements of a collection, like finding the largest element based on some Comparator object, finding the smallest element, finding sublists within a list, reverse the contents of a list, shuffle the contents of a list, create immutable versions of a collection, performs sorts, and make binary searches.","The C# collections framework consists of classes from the  and the  namespaces with a number of useful interfaces, abstract classes, and data structures. Net 3.5 added  namespace contains various extension methods for querying collections, such as , , , , ,  and many others. Queries using these methods are called LINQ queries."
"Java","C#"
"Metadata","Java","C#"
"Metadata annotations/attributes","Interface based; user-defined annotations can be created","Class based"
"Positional arguments","No; unless a single argument","Yes"
"Named arguments","Yes","Yes"
"Default values","At definition","Through initialization"
"Nested types","Yes","Yes"
"Specialization","No","Yes"
"Conditional metadata","No","Yes"
"Preprocessing, Compilation and Packaging","Java","C#"
"Namespaces","Packages","Namespaces"
"File contents","Restricted","Free"
"Packaging","Package","Assembly"
"Classes/assembly search path","ClassPath","Both compile-time and runtime"
"Conditional compilation","Yes","Yes"
"Custom errors/warnings","Yes; AnnotationProcessor","Yes"
"Explicit regions","No","Yes"
"Threading and Synchronization","Java","C#"
"Threads","Yes","Yes"
"Thread pool","Yes","Yes"
"Task-based parallelism","Partial","Yes"
"Semaphores","Yes","Yes"
"Monitors","Yes","Yes"
"Thread-local variables","Yes","Yes; ThreadStaticAttribute"
"Native interoperability","Java","C#"
"Cross-language interoperability","Yes (with Nashorn, CORBA, JNI or JNA)","Yes; C# was designed for it"
"External/native methods","Yes","Yes"
"Marshalling","External glue code required","Yes; metadata controlled"
"Pointer and arithmetics","No; but references exist","Yes"
"Native types","Yes","Yes"
"Fixed-size buffers","No","Yes"
"Explicit stack allocation","No","Yes"
"Address-of","No","Yes"
"Object pinning (fix variable to address)","No","Yes"
"Platform support","Java","C#"
"Linux","Yes","via Mono"
"Mac OS X","Yes","via Mono"
"Solaris","Yes","via Mono"
"FreeBSD","Yes","via Mono"
"AIX","Yes","Partial?"
"iOS","via RoboVM or Codename One","via Mono"
"Windows","Yes","Yes"
"Windows Mobile","Yes","Yes"
"Windows Phone","via Codename One","Yes"
"Android","via Dalvik, ART","via Mono"
"Feature phones","Yes","No"
"Symbian","Yes","Deprecated"
"Blackberry","Yes","via cross-compiler"
"keyword","feature, example usage"
",","In C#,  statement blocks or expressions can enable run-time checking for arithmetic overflow."
",","C# implements properties as part of the language syntax with their optional corresponding  and  accessors, as an alternative for the accessor method used in Java, which is not a language feature but a coding-pattern based on method name conventions."
"","C# supports the  keyword. This can occasionally be useful, for example for implementing finite state machine or for generated code, but the use of a more structured method of control flow is usually recommended (see criticism of the goto statement). Java does not support the  statement (but  is a reserved word). However, Java does support labeled  and  statements, which in certain situations can be used when a  statement might otherwise be used."
"","In C#, the  keyword is a shorthand for synchronizing access to a block of code across threads (using a ), wrapped in a  …  block."
",","C# has support for output and reference parameters. These allow returning multiple output values from a method, or passing values by reference."
"","Java uses  to guarantee the results of floating point operations remain the same across platforms."
"","In C#, the switch statement also operates on strings and longs. Fallthrough is allowed for empty statements and possible via 'goto case' for statements containing code. Java's switch statement does not operate on strings (before Java 7) nor  primitive type but falls through for all statements (excluding those with '')."
"","In Java, the  keyword is a shorthand for synchronizing access to a block of code across threads (using a ), wrapped in a  …  block."
"","Java requires every method to declare the checked exceptions or superclasses of the checked exceptions that it can throw. Any method can also optionally declare the unchecked exception that it throws. C# has no such syntax."
"","In C#,  causes the  method (implemented via the  interface) of the object declared to be executed after the code block has run or when an exception is thrown within the code block.In Java SE 7 a similar construct has been added called try-with-resources :"
"Java","C#"
"",""
"Notes on the Java implementation: Files.readAllBytes method reads a whole file into a byte array.
 Files.write method writes a byte array into an output file, indicated by a Path object.
 Files.write method also takes care of buffering and closing the output stream.
 An explicit option should be specified for the Files.write method whether it should overwrite or append to the output file.
 StandardOpenOption.CREATE indicates that the output file should be created or overwritten if exists.","Notes on the C# implementation: The  method returns an enumerable object which upon enumeration will read the file one line at a time.
 The  method takes an enumerable and retrieves a line at a time and writes it until the enumeration ends.
 The underlying reader will automatically allocate a buffer, thus there is no need to explicitly introduce a buffered stream.
  automatically closes the output stream, also in the case of an abnormal termination."
"Java","C#"
"",""
"Java","C#"
"",""
"Java","C#"
"",""
"Java","C#","/!\ This cell is not defined /!\"
"","","/!\ This cell is not defined /!\"
"","","/!\ This cell is not defined /!\"
"Notes for the Java implementation: Ruby accessors names are generated from the attribute name with a  suffix. When assigning values, Java developers must use the Ruby accessor method name.
 Dynamic objects from a foreign language are not first-class objects in that they must be manipulated through an API.","Notes for the C# implementation: Objects returned from properties or methods of  objects are themselves of  type. When type inference (the  keyword) is used, the variables calc and answer are inferred dynamic/late-bound.
 Dynamic, late-bounds objects are first-class citizens that can be manipulated using C# syntax even though they have been created by an external language.
 is a reserved word. The  prefix allows keywords to be used as identifiers.",""
"Java","C#"
"||","/!\ This cell is not defined /!\"
"",""
"Java","C#"